@article{alseqyani2023history,
  author  = {A. Alseqyani and A. Almutairi},
  title   = {History and Future Trends of Multicore Computer Architecture},
  journal = {International Journal of Computer Graphics \& Animation},
  volume  = {13},
  number  = {2},
  pages   = {01--08},
  year    = {2023},
  month   = {Apr.},
  doi     = {10.5121/ijcga.2023.13201}
}
@misc{mitConcurrency,
  title        = {Reading 17: Concurrency},
  author       = {{MIT}},
  howpublished = {\url{https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/}},
  note         = {Accessed: 2025-04-29}
}
@article{alseqyani2023historyOfConcurrency,
  author  = {A. Alseqyani and A. Almutairi},
  title   = {History and Future Trends of Multicore Computer Architecture},
  journal = {International Journal of Computer Graphics \& Animation},
  volume  = {13},
  number  = {2},
  pages   = {01--08},
  year    = {2023},
  month   = {Apr.},
  doi     = {10.5121/ijcga.2023.13201}
}

@article{huang2016debuggingConcurrentPrograms,
  author  = {J. Huang and C. Zhang},
  title   = {Debugging Concurrent Software: Advances and Challenges},
  journal = {Journal of Computer Science and Technology},
  volume  = {31},
  number  = {5},
  pages   = {861--868},
  year    = {2016},
  month   = {Sep.},
  doi     = {10.1007/s11390-016-1669-8}
}

@article{andrews1983conceptsOfConcurrency,
  author  = {G. R. Andrews and F. B. Schneider},
  title   = {Concepts and Notations for Concurrent Programming},
  journal = {ACM Computing Surveys (CSUR)},
  volume  = {15},
  number  = {1},
  pages   = {3--43},
  year    = {1983},
  month   = {Mar.},
  doi     = {10.1145/356901.356903}
}

@inproceedings{armstrong2007historyOfErlang,
  author    = {J. Armstrong},
  title     = {A history of Erlang},
  booktitle = {Proceedings of the third ACM SIGPLAN conference on History of programming languages},
  year      = {2007},
  month     = {Jun.},
  doi       = {10.1145/1238844.1238850}
}
@inproceedings{jaffe2011impactOfMemoryModels,
  author    = {Jaffe, Alexander and Moscibroda, Thomas and Effinger-Dean, Laura and Ceze, Luis and Strauss, Karin},
  title     = {The impact of memory models on software reliability in multiprocessors},
  year      = {2011},
  isbn      = {9781450307192},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi-org.libaccess.sjlibrary.org/10.1145/1993806.1993819},
  doi       = {10.1145/1993806.1993819},
  abstract  = {The memory consistency model is a fundamental system property characterizing a multiprocessor. The relative merits of strict versus relaxed memory models have been widely debated in terms of their impact on performance, hardware complexity and programmability. This paper adds a new dimension to this discussion: the impact of memory models on software reliability. By allowing some instructions to reorder, weak memory models may expand the window between critical memory operations. This can increase the chance of an undesirable thread-interleaving, thus allowing an otherwise-unlikely concurrency bug to manifest. To explore this phenomenon, we define and study a probabilistic model of shared-memory parallel programs that takes into account such reordering. We use this model to formally derive bounds on the vulnerability to concurrency bugs of different memory models. Our results show that for 2 concurrent threads, weaker memory models do indeed have a higher likelihood of allowing bugs. On the other hand, we show that as the number of parallel, buggy threads increases, the gap between the different memory models becomes proportionally insignificant, and thus the importance of using a strict memory model diminishes.},
  booktitle = {Proceedings of the 30th Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing},
  pages     = {89–98},
  numpages  = {10},
  keywords  = {weak ordering, total store order, software reliability, sequential consistency, probabilistic analysis, memory consistency models},
  location  = {San Jose, California, USA},
  series    = {PODC '11}
}
@inproceedings{kendoEfficientDeterministicMultithreading,
  author    = {Olszewski, Marek and Ansel, Jason and Amarasinghe, Saman},
  title     = {Kendo: efficient deterministic multithreading in software},
  year      = {2009},
  isbn      = {9781605584065},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi-org.libaccess.sjlibrary.org/10.1145/1508244.1508256},
  doi       = {10.1145/1508244.1508256},
  abstract  = {Although chip-multiprocessors have become the industry standard, developing parallel applications that target them remains a daunting task. Non-determinism, inherent in threaded applications, causes significant challenges for parallel programmers by hindering their ability to create parallel applications with repeatable results. As a consequence, parallel applications are significantly harder to debug, test, and maintain than sequential programs.This paper introduces Kendo: a new software-only system that provides deterministic multithreading of parallel applications. Kendo enforces a deterministic interleaving of lock acquisitions and specially declared non-protected reads through a novel dynamically load-balanced deterministic scheduling algorithm. The algorithm tracks the progress of each thread using performance counters to construct a deterministic logical time that is used to compute an interleaving of shared data accesses that is both deterministic and provides good load balancing. Kendo can run on today's commodity hardware while incurring only a modest performance cost. Experimental results on the SPLASH-2 applications yield a geometric mean overhead of only 16\% when running on 4 processors. This low overhead makes it possible to benefit from Kendo even after an application is deployed. Programmers can start using Kendo today to program parallel applications that are easier to develop, debug, and test.},
  booktitle = {Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {97–108},
  numpages  = {12},
  keywords  = {debugging, determinism, deterministic multithreading, multicore, parallel programming},
  location  = {Washington, DC, USA},
  series    = {ASPLOS XIV}
}
@misc{rookout2021heisenbug,
  author       = {O. W.},
  title        = {What Is A Heisenbug: Full Guide - Rookout.com},
  howpublished = {\url{https://www.rookout.com/blog/fantastic-bugs-and-how-to-resolve-them-ep1-heisenbugs/}},
  month        = sep,
  year         = {2021},
  note         = {Accessed: 2025-04-29}
}
@inproceedings{gray1986whyComputersStop,
  author    = {Gray, J.},
  title     = {Why do computers stop and what can be done about it?},
  booktitle = {Proceedings of the 5th Symposium on Reliability in Distributed Software and Database Systems},
  year      = {1986},
  month     = {Jan.},
  pages     = {3--12}
}
@misc{leroy2021sharedMemorySlides,
  author       = {Xavier Leroy},
  title        = {Shared-memory concurrency: Concurrent separation logic},
  howpublished = {Presentation slide},
  month        = {Mar.},
  year         = {2021},
  note         = {Accessed: 2025-04-29},
  url          = {https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://xavierleroy.org/CdF/2020-2021/4.pdf&ved=2ahUKEwin-ZbexYCNAxXKyOYEHRLNFnEQFnoECBcQAQ&usg=AOvVaw3JZThu0tD7pelz9PZX6JfH}
}
@misc{csf2025synchronizationPrimitives,
  title        = {7.1. Synchronization Primitives — Computer Systems Fundamentals},
  howpublished = {\url{https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/SynchOverview.html}},
  author       = {{w3.cs.jmu.edu}},
  note         = {Accessed: 2025-04-29}
}
@misc{csf2025synchronizationDesign,
  title        = {8.2. Basic Synchronization Design Patterns — Computer Systems Fundamentals},
  howpublished = {\url{https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/SynchDesign.html}},
  author       = {{w3.cs.jmu.edu}},
  note         = {Accessed: 2025-04-29}
}
@misc{bornholt2016memoryModels,
  author       = {James Bornholt},
  title        = {Memory Consistency Models: A Tutorial},
  howpublished = {\url{https://jamesbornholt.com/blog/memory-models/}},
  year         = {2016},
  note         = {Accessed: 2025-05-01}
}
@article{lamport1979multiprocessor,
  author  = {L. Lamport},
  title   = {How to make a multiprocessor computer that correctly executes multiprocess programs},
  journal = {IEEE Transactions on Computers},
  volume  = {28},
  number  = {9},
  pages   = {690--691},
  year    = {1979},
  month   = {Sep.}
}
@misc{cox2021hardwareMemoryModels,
  author       = {R. Cox},
  title        = {research!rsc: Hardware Memory Models (Memory Models, Part 1)},
  howpublished = {\url{https://research.swtch.com/hwmm}},
  year         = {2021},
  note         = {Accessed: 2025-05-01}
}
@INPROCEEDINGS{8316391,
  author={Aning, Kwabena and Mannock, Keith Leonard},
  booktitle={2017 8th International Conference on Information, Intelligence, Systems \& Applications (IISA)}, 
  title={An architecture and implementation of the actor model of concurrency}, 
  year={2017},
  volume={},
  number={},
  pages={1-6},
  keywords={Message systems;Concurrent computing;Libraries;Computer languages;Computer architecture;Parallel processing;Message passing;Distributed computing;Design and implementation;Software Architectures;Parallel and Concurrent Computing;Agent Architecture;Programming languages},
  doi={10.1109/IISA.2017.8316391}}
@INPROCEEDINGS{10820772,
  author={Klenk, Kyle and Moayeri, Mohammad Mahdi and Guo, Junwei and Clark, Martyn P. and Spiteri, Raymond J.},
  booktitle={SC24-W: Workshops of the International Conference for High Performance Computing, Networking, Storage and Analysis}, 
  title={Mitigating synchronization bottlenecks in high-performance actor-model-based software}, 
  year={2024},
  volume={},
  number={},
  pages={1274-1287},
  keywords={Concurrent computing;Analytical models;Computational modeling;High performance computing;Conferences;Programming;Software;Synchronization;North America;Load modeling;actor model of concurrent computing;high-throughput computing;scientific and high-performance computing;bulk synchronous programming;fork-join pattern},
  doi={10.1109/SCW63240.2024.00168}}
@INPROCEEDINGS{8892329,
  author={Al-Twajre, Baseem A.},
  booktitle={2019 XIth International Scientific and Practical Conference on Electronics and Information Technologies (ELIT)}, 
  title={Performance Analysis of Messages Queue in the Different Actor System Implementation}, 
  year={2019},
  volume={},
  number={},
  pages={127-131},
  keywords={Computational modeling;Biological system modeling;Libraries;Benchmark testing;Message systems;Java;Information technology;Actor Model;Performance;actor mailboxes},
  doi={10.1109/ELIT.2019.8892329}}
@article{replayDeterminism,
  author     = {Russinovich, Mark and Cogswell, Bryce},
  title      = {Replay for concurrent non-deterministic shared-memory applications},
  year       = {1996},
  issue_date = {May 1996},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {31},
  number     = {5},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/249069.231432},
  doi        = {10.1145/249069.231432},
  abstract   = {Replay of shared-memory program execution is desirable in many domains including cyclic debugging, fault tolerance and performance monitoring. Past approaches to repeatable execution have focused on the problem of re-executing the shared-memory access patterns in parallel programs. With the proliferation of operating system supported threads and shared memory for uniprocessor programs, there is a clear need for efficient replay of concurrent applications. The solutions for parallel systems can be performance prohibitive when applied to the uniprocessor case. We present an algorithm, called the repeatable scheduling algorithm, combining scheduling and instruction counts to provide an invariant for efficient, language independent replay of concurrent shared-memory applications. The approach is shown to have trace overheads that are independent of the amount of sharing that takes place. An implementation for cyclic debugging on Mach 3.0 is evaluated and benchmarks show typical performance overheads of around 10\%. The algorithm implemented is compared with optimal event-based tracing and shown to do better with respect to the number of events monitored or number of events logged, in most cases by several orders of magnitude.},
  journal    = {SIGPLAN Not.},
  month      = may,
  pages      = {258–266},
  numpages   = {9},
  keywords   = {instruction counter, non-determinism, repeatable execution, shared memory}
}
@inproceedings{hardwareDeterminism,
  author    = {Joe Devietti and Brandon Lucia and Luis Ceze and Mark Oskin},
  title     = {Explicitly parallel programming with shared-memory is insane: At least make it deterministic!},
  booktitle = {Proceedings of SHCMP 2008: Workshop on Software and Hardware Challenges of Manycore Platforms},
  address   = {Beijing, China},
  month     = {Jun.},
  year      = {2008}
}
@article{10.1145/357980.358021,
author = {Hoare, C. A. R.},
title = {Communicating sequential processes},
year = {1983},
issue_date = {Jan. 1983},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/357980.358021},
doi = {10.1145/357980.358021},
abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar programming exercises.},
journal = {Commun. ACM},
month = jan,
pages = {100–106},
numpages = {7},
keywords = {classes, concurrency, conditional critical regions, coroutines, data representations, guarded commands, input, iterative arrays, monitors, multiple entries, multiple exits, nondeterminacy, output, parallel programming, procedures, program structures, programming, programming languages, programming primitives, recursion}
}

@article{10.1145/173682.165164,
author = {Herlihy, Maurice and Moss, J. Eliot B.},
title = {Transactional memory: architectural support for lock-free data structures},
year = {1993},
issue_date = {May 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {2},
issn = {0163-5964},
url = {https://doi.org/10.1145/173682.165164},
doi = {10.1145/173682.165164},
abstract = {A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture intended to make lock-free synchronization as efficient (and easy to use) as conventional techniques based on mutual exclusion. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any multiprocessor cache-coherence protocol. Simulation results show that transactional memory matches or outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock.},
journal = {SIGARCH Comput. Archit. News},
month = may,
pages = {289–300},
numpages = {12}
}

@inproceedings{herlihy1993hardware,
author = {Herlihy, Maurice and Moss, J. Eliot B.},
title = {Transactional memory: architectural support for lock-free data structures},
year = {1993},
isbn = {0818638109},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/165123.165164},
doi = {10.1145/165123.165164},
abstract = {A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture intended to make lock-free synchronization as efficient (and easy to use) as conventional techniques based on mutual exclusion. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any multiprocessor cache-coherence protocol. Simulation results show that transactional memory matches or outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock.},
booktitle = {Proceedings of the 20th Annual International Symposium on Computer Architecture},
pages = {289–300},
numpages = {12},
location = {San Diego, California, USA},
series = {ISCA '93}
}

@inproceedings{shavit1995software,
author = {Shavit, Nir and Touitou, Dan},
title = {Software transactional memory},
year = {1995},
isbn = {0897917103},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/224964.224987},
doi = {10.1145/224964.224987},
booktitle = {Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing},
pages = {204–213},
numpages = {10},
location = {Ottowa, Ontario, Canada},
series = {PODC '95}
}

@article{kestlerBMC,
author = {Kraus, Johann and Kestler, Hans},
year = {2010},
month = {04},
pages = {169},
title = {A highly efficient multi-core algorithm for clustering extremely large datasets},
volume = {11},
journal = {BMC bioinformatics},
doi = {10.1186/1471-2105-11-169}
}

@inproceedings{harrisComposable,
author = {Harris, Tim and Marlow, Simon and Peyton-Jones, Simon and Herlihy, Maurice},
title = {Composable memory transactions},
year = {2005},
isbn = {1595930809},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1065944.1065952},
doi = {10.1145/1065944.1065952},
abstract = {Writing concurrent programs is notoriously difficult, and is of increasing practical importance. A particular source of concern is that even correctly-implemented concurrency abstractions cannot be composed together to form larger abstractions. In this paper we present a new concurrency model, based on transactional memory, that offers far richer composition. All the usual benefits of transactional memory are present (e.g. freedom from deadlock), but in addition we describe new modular forms of blocking and choice that have been inaccessible in earlier work.},
booktitle = {Proceedings of the Tenth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {48–60},
numpages = {13},
keywords = {transactions, non-blocking algorithms, locks},
location = {Chicago, IL, USA},
series = {PPoPP '05}
}
@inproceedings{harrisLockFree,
author = {Discolo, Anthony and Harris, Tim and Marlow, Simon and Jones, Simon Peyton and Singh, Satnam},
title = {Lock free data structures using STM in haskell},
year = {2006},
isbn = {3540334386},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/11737414_6},
doi = {10.1007/11737414_6},
abstract = {This paper explores the feasibility of re-expressing concurrent algorithms with explicit locks in terms of lock free code written using Haskell's implementation of software transactional memory. Experimental results are presented which show that for multi-processor systems the simpler lock free implementations offer superior performance when compared to their corresponding lock based implementations.},
booktitle = {Proceedings of the 8th International Conference on Functional and Logic Programming},
pages = {65–80},
numpages = {16},
location = {Fuji-Susono, Japan},
series = {FLOPS'06}
}
@inproceedings{harrisTransactional,
author = {Harris, Tim and Peyton Jones, Simon},
title = {Transactional memory with data invariants},
booktitle = {First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT'06)},
year = {2006},
month = {June},
abstract = {This paper introduces a mechanism for asserting invariants that are maintained by a program that uses atomic memory transactions. The idea is simple: a programmer writes check E where E is an expression that should be preserved by every atomic update for the remainder of the program's execution. We have extended STM Haskell to dynamically evaluate check statements atomically with the user's updates: the result is that we can identify precisely which update is the first one to break an invariant.},
url = {https://www.microsoft.com/en-us/research/publication/transactional-memory-data-invariants/},
edition = {First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT'06)},
}

@misc{bartoszBeyondLocks,
  title        = {Beyond Locks: Software Transactional Memory },
  author       = {Milewski,Bartosz},
  howpublished = {\url{https://bartoszmilewski.com/2010/09/11/beyond-locks-software-transactional-memory/}},
  note         = {Accessed: 2025-05-01}
}
@misc{tankenobuWiki,
  title        = {GHC Commentary: Software Transactional Memory (STM)},
  author       = {Tani, Tonkenobu},
  howpublished = {\url{https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/stm}},
  note         = {Accessed: 2025-05-01}
}

@misc{haskellWiki,
  title        = {Software transactional memory},
  howpublished = {\url{https://wiki.haskell.org/Software_transactional_memory}},
  note         = {Accessed: 2025-05-01}
}


@misc{news.ycombinator.com,
  title        = {Ruby's Proposed STM},
  howpublished = {\url{https://news.ycombinator.com/item?id=24921657/}},
  note         = {Accessed: 2025-05-01}
}

@misc{volkmannClojure,
  title        = {Software Transactional Memory},
  author       = {Volkmann, R. Mark},
  howpublished = {\url{https://mvolkmann.github.io/stm/article.html}},
  note         = {Accessed: 2025-05-01}
}
@misc{hickeyRationale,
  title        = {Rationale},
  author       = {Hickey, Rich},
  howpublished = {\url{https://clojure.org/about/rationale}},
  note         = {Accessed: 2025-05-01}
}

@misc{rustWiki,
  howpublished = {\url{https://doc.rust-lang.org/book/#the-rust-programming-language}},
  note         = {Accessed: 2025-05-01}
}

@misc{rustSTM,
  howpublished = {\url{https://crates.io/crates/stm}},
  note         = {Accessed: 2025-05-01}
}

@misc{asyncRustSTM,
  author       = {Farkash, Aakosh},
  howpublished = {\url{github.com/aakoshh/async-stm-rs}},
  note         = {Accessed: 2025-05-01}
}
@INPROCEEDINGS{nordTortis,
  author={Nord, Claire and Caspin, Shai and Nemitz, Catherine E. and Shrobe, Howard and Okhravi, Hamed and Anderson, James H. and Burow, Nathan and Ward, Bryan C.},
  booktitle={2021 IEEE Real-Time Systems Symposium (RTSS)}, 
  title={TORTIS: Retry-Free Software Transactional Memory for Real-Time Systems}, 
  year={2021},
  volume={},
  number={},
  pages={469-481},
  keywords={Concurrent computing;Embedded computing;Codes;Costs;Programming;Throughput;Real-time systems;transactional memory;software transactional memory;real time},
  doi={10.1109/RTSS52674.2021.00049}
  }

@misc{infoq.com,
  title        = {Microsoft’s Experiments with Software Transactional Memory Have Ended},
  author       = {Allen, Jonathan},
  howpublished = {\url{https://www.infoq.com/news/2010/05/STM-Dropped}},
  note         = {Accessed: 2025-05-01}
}
@misc{pypy.org,
  title        = {We need Software Transactional Memory},
  author       = {Rigo, Armin},
  howpublished = {\url{https://pypy.org/posts/2011/08/we-need-software-transactional-memory-6513983438425039230.html}},
  note         = {Accessed: 2025-05-01}
}
@misc{docs.akka.io,
  howpublished = {\url{https://doc.akka.io/libraries/akka/1.2/scala/stm.html}},
  note         = {Accessed: 2025-05-01}
}

@misc{groups.google.com,
  howpublished = {\url{https://groups.google.com/g/akka-user/c/3JWz-X5dbe8/m/YiV4WFG0qh0J}},
  note         = {Accessed: 2025-05-01}
}

