\section{Introduction\label{sec:introduction}}
Concurrent programming is the process of modeling and
developing algorithms where a task can be decomposed into
two or more subroutines that execute at the same time or in well-defined turns.
Between 2005 and 2010, the ``multicore revolution" drove a major shift in consumer computing,
making multicore CPUs standard even in low-end devices~\cite{alseqyani2023history}.
As a result, multicore computer architectures are ubiquitous in todayâ€™s computing environment.

Single-threaded programs can not take advantage of the full computing power of a multicore architecture.
This is particularly true when a program can be designed to run concurrently.
However, writing and debugging concurrent programs is difficult~\cite{huang2016debuggingConcurrentPrograms}.
The primary difficulty comes from the following relation: computer programs
are written by humans using programming languages. 
When developing concurrent programs, programming languages and developers
follow a given concurrency model. The following survey aims to describe
and compared the Shared-Memory, Actor-Model, and Software Transactional Memory
concurrency models.

In Section~\ref{sec:shared_memory},
we describe the Shared-Memory concurrency model,
where processes or threads communicate by reading and writing
to shared memory.
Furthermore, this section discusses 
synchronization primitives such as locks, semaphores,
and monitors to address race conditions and deadlocks.
Additionally, this section explains memory consistency models,
their impact on instruction ordering,
and strategies like deterministic multithreading
and replay systems to mitigate
non-determinism in shared-memory systems.

Although concurrent programs can be written using the SM concurrency
model, concurrency in modern software systems needs abstractions
that simplify reasoning and fully exploit distributed
architectures as discussed in \cite{10.1145/357980.358021}.
The Actor Model provides an abstraction by encapsulating state
with independent actors that communicate only through
asynchronous messaging. In Section~\ref{sec:actor},
we examine how mailbox structures, dispatcher strategies,
and actor hierarchies interact to optimize scalability, fault tolerance,
and programmability in actor-based systems.