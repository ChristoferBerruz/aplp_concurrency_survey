\documentclass[12pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage{multicol}
\usepackage{array}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{tcolorbox}
\usepackage{float}

\usetikzlibrary{arrows.meta}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
}
\newenvironment{code}{\fontfamily{zi4}\selectfont}{\par}
\DeclareTextFontCommand{\codeify}{\code}


% Document
\begin{document}

\title{Comparison in Concurrency Models in different programming languages}
\author{
    Christofer Washington Berruz Chungata \\ 
    Karan Jain \\ 
    Amey Makarand Dhongade \\ 
    \\
    San Jos\'{e} State University \\ 
    CS 252 - Final Project
}
\date{May 12, 2025}

\maketitle

\begin{abstract}
This project is very abstract
\end{abstract}

\section{Introduction\label{sec:introduction}}
Concurrent programming is the process of modeling and
developing algorithms where a task can be decomposed into
two or more subroutines that execute at the same time or in well-defined turns.
Between 2005 and 2010, the "multicore revolution" drove a major shift in consumer computing,
making multicore CPUs standard even in low-end devices~\cite{alseqyani2023history}.
As a result, multicore computer architectures are ubiquitous in todayâ€™s computing environment.

Single-threaded programs can not take advantage of the full computing power of a multicore architecture.
This is particularly true when a program can be designed to run concurrently.
However, writing and debugging concurrent programs is difficult~\cite{huang2016debuggingConcurrentPrograms}.
The primary difficulty comes from the following relation: computer programs
are written by humans using programming languages. 
When developing concurrent programs, programming languages and developers
follow a given concurrency model. The following survey aims to describe
and compared the Shared-Memory, Actor-Model, and Software Transactional Memory
concurrency models.

Furthermore, concurrency in modern software systems needs abstractions
that simplify reasoning and fully exploit distributed
architectures as discussed in \cite{10.1145/357980.358021}.
The Actor Model provides an abstraction by encapsulating state
with independent actors that communicate only through
asynchronous messaging. In \autoref{sec:actor}
we examine how mailbox structures, dispatcher strategies,
and actor hierarchies interact to optimize scalability, fault tolerance,
and programmability in actor-based systems.

\input{shared_memory.tex}
\input{actor_model.tex}
\input{stm.tex}

% Bibliography
\bibliographystyle{plain}
\bibliography{references}

\end{document}