\section{Conclusion\label{sec:conclusion}}
In this survey we described the Shared-Memory (SM),
Actor-Model (AM), and Software Transactional Memory (STM)
concurrency models.

Although the SM concurrency model is the
easiest form of concurrency that a programming language
can support, it is also plagued with disadvantage.
Synchronization primitives, useful to create
correct programs and protect critical sections, can be
misused by developers leading to deadlocks. Even though
several design patterns exists, including mutexes, turnstiles,
and rendezvous, these patterns impose an extra
complexity later. Furthermore, it is
the responsibility
of the developer to choose which pattern to use depending
on the problem. Even seemingly correct concurrent programs
can have bugs. In the SM concurrency models, these bugs
are hard to reproduce given the interleaving problem
caused by different memory consistency models at the compiler
or Operating System level. One primary cause of the lack
of reproducibility is the lack of determinism. In this area, there
have been multiple attempts to improve determinism in SM models
including replay/record systems, hardware determinism,
and software only determinism framework relying on 
Deterministic Logical Time.

STM remains an elegant concurrency model and it
continues to be supported (implemented), notably by Haskell and Clojure.
In these environments, immutability and strong typing compliment STM’s complexity,
and the smaller and academically minded community is comfortable with its cost
in exchange for composability and safety. In more conventional and corporate
backed ecosystems like .NET, Python or JVM, STM has largely been sidelined
in favor of established models like that of task-actor-message models;
ones that align with the easier idioms and tooling.
Performance considerations, difficulty with I/O and legacy code,
and the lack of a “killer app” cemented STM’s decline.
Each community made reasonable choice: either optimize
around STM or pivot to alternatives better suited.
It is not a Swiss Army knife, but a scalpel for specific use cases.

Although the actor model provides a clear conceptual framework encapsulating state 
within independent actors and communicating solely via asynchronous messages, 
it is not without its challenges. Message ordering is inherently 
non-deterministic, making subtle bugs difficult to reproduce. 
Developers must experiment with supervision hierarchies, 
mailbox sizing, back-pressure strategies, and failure propagation 
patterns to ensure correct, performant behavior. Each of these 
constructs, while powerful, adds cognitive overhead, and integrating 
actor-based designs with legacy synchronous I/O or shared-memory libraries 
can introduce additional friction. Under heavy load, the serialization and 
queueing of messages may also incur performance overhead that requires careful 
tuning of dispatchers and routing strategies. In production, mature frameworks 
like Akka on the JVM, show how the actor model can yield highly available, 
fault-tolerant systems with dynamic scaling and location transparency. Their 
ecosystems offer robust tooling for monitoring, clustering, and supervised 
restarts, and their communities value the model’s composability and resilience. 